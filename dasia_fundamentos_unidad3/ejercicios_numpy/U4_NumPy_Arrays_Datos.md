# U4 - NumPy: Fundamentos de arrays y computación científica
---
## 1. Introducción a NumPy

### ¿Qué es NumPy?
NumPy (Numerical Python) es la biblioteca fundamental para computación científica en Python. Proporciona:

- **Arrays multidimensionales** eficientes (ndarray)
- **Funciones matemáticas** de alto rendimiento
- **Herramientas** para trabajar con álgebra lineal
- **Base** para otras bibliotecas como Pandas, Scikit-learn, TensorFlow

### ¿Por qué NumPy es crucial para IA?

```python
import numpy as np
import time

# Comparación de rendimiento: Python puro vs NumPy
def suma_python_puro(lista):
    resultado = []
    for i in range(len(lista)):
        resultado.append(lista[i] + 1)
    return resultado

def suma_numpy(array):
    return array + 1

# Crear datos de prueba
datos = list(range(1000000))
array_np = np.array(datos)

# Medir tiempos
start = time.time()
resultado_python = suma_python_puro(datos)
tiempo_python = time.time() - start

start = time.time()
resultado_numpy = suma_numpy(array_np)
tiempo_numpy = time.time() - start

print(f"Python puro: {tiempo_python:.4f} segundos")
print(f"NumPy: {tiempo_numpy:.4f} segundos")
print(f"NumPy es {tiempo_python/tiempo_numpy:.1f}x más rápido")
```
---
## 2. Arrays de NumPy (ndarray)

### 2.1 Creación de arrays

```python
import numpy as np

# Desde listas
arr_1d = np.array([1, 2, 3, 4, 5])
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
arr_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])

print("Array 1D:", arr_1d)
print("Array 2D:\n", arr_2d)
print("Array 3D:\n", arr_3d)

# Funciones de creación
zeros = np.zeros((3, 4))           # Array de ceros
ones = np.ones((2, 3))             # Array de unos
empty = np.empty((2, 2))           # Array sin inicializar
eye = np.eye(3)                    # Matriz identidad
full = np.full((2, 3), 7)          # Array con valor específico

# Rangos y secuencias
arange = np.arange(0, 10, 2)       # [0, 2, 4, 6, 8]
linspace = np.linspace(0, 1, 5)    # [0, 0.25, 0.5, 0.75, 1]

# Arrays aleatorios
random_uniform = np.random.random((3, 3))     # Uniforme [0, 1)
random_normal = np.random.normal(0, 1, (3, 3))  # Normal μ=0, σ=1
random_int = np.random.randint(0, 10, (3, 3))   # Enteros aleatorios
```

### 2.2 Propiedades de arrays

```python
arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(f"Forma (shape): {arr.shape}")           # (2, 4)
print(f"Dimensiones: {arr.ndim}")              # 2
print(f"Tamaño total: {arr.size}")             # 8
print(f"Tipo de datos: {arr.dtype}")           # int64 (puede variar)
print(f"Tamaño en bytes: {arr.nbytes}")        # 64 (8 elementos × 8 bytes)
print(f"Memoria por elemento: {arr.itemsize}") # 8 bytes
```

### 2.3 Tipos de datos en NumPy

```python
# Especificar tipos de datos explícitamente
arr_int8 = np.array([1, 2, 3], dtype=np.int8)      # Entero 8 bits
arr_float32 = np.array([1, 2, 3], dtype=np.float32) # Float 32 bits
arr_bool = np.array([True, False, True])             # Booleano

# Conversión de tipos
arr = np.array([1.7, 2.3, 3.9])
arr_int = arr.astype(np.int32)  # [1, 2, 3]
arr_str = arr.astype(str)       # ['1.7', '2.3', '3.9']

print("Original:", arr)
print("Como entero:", arr_int)
print("Como string:", arr_str)
```
---
## 3. Indexación y slicing

### 3.1 Arrays unidimensionales

```python
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

# Indexación básica
print(arr[0])        # 0 (primer elemento)
print(arr[-1])       # 9 (último elemento)

# Slicing
print(arr[2:5])      # [2, 3, 4]
print(arr[:3])       # [0, 1, 2]
print(arr[7:])       # [7, 8, 9]
print(arr[::2])      # [0, 2, 4, 6, 8] (cada 2 elementos)
print(arr[::-1])     # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (reverso)
```

### 3.2 Arrays multidimensionales

```python
arr_2d = np.array([[1, 2, 3, 4],
                   [5, 6, 7, 8],
                   [9, 10, 11, 12]])

# Indexación
print(arr_2d[1, 2])     # 7 (fila 1, columna 2)
print(arr_2d[1][2])     # 7 (alternativa, menos eficiente)

# Slicing de filas y columnas
print(arr_2d[1:])       # Filas 1 en adelante
print(arr_2d[:, 1:3])   # Todas las filas, columnas 1-2
print(arr_2d[1:, 1:3])  # Filas 1+, columnas 1-2

# Indexación avanzada
filas = [0, 2]
columnas = [1, 3]
print(arr_2d[filas, :][:, columnas])  # Filas 0,2 y columnas 1,3
```

### 3.3 Indexación booleana

```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])

# Crear máscara booleana
mask = arr > 5
print("Máscara:", mask)              # [False False False False False True True True True]
print("Elementos > 5:", arr[mask])   # [6 7 8 9]

# Condiciones complejas
mask_compleja = (arr > 3) & (arr < 8)
print("Entre 3 y 8:", arr[mask_compleja])  # [4 5 6 7]

# Modificación con máscaras
arr[arr > 7] = 0
print("Modificado:", arr)  # [1 2 3 4 5 6 7 0 0]
```
---
## 4. Operaciones con arrays

### 4.1 Operaciones aritméticas

```python
arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([10, 20, 30, 40])

# Operaciones elemento a elemento
suma = arr1 + arr2        # [11, 22, 33, 44]
resta = arr2 - arr1       # [9, 18, 27, 36]
multiplicacion = arr1 * arr2  # [10, 40, 90, 160]
division = arr2 / arr1    # [10.0, 10.0, 10.0, 10.0]
potencia = arr1 ** 2      # [1, 4, 9, 16]

# Operaciones con escalares (broadcasting)
arr = np.array([1, 2, 3, 4])
resultado = arr * 2 + 1   # [3, 5, 7, 9]

print("Suma:", suma)
print("Con escalar:", resultado)
```

### 4.2 Funciones matemáticas universales (ufuncs)

```python
arr = np.array([1, 4, 9, 16, 25])

# Funciones matemáticas
sqrt_arr = np.sqrt(arr)           # Raíz cuadrada
log_arr = np.log(arr)             # Logaritmo natural
exp_arr = np.exp([1, 2, 3])       # Exponencial

# Funciones trigonométricas
angles = np.array([0, np.pi/2, np.pi])
sin_arr = np.sin(angles)          # [0, 1, 0]
cos_arr = np.cos(angles)          # [1, 0, -1]

# Funciones de redondeo
arr_float = np.array([1.2, 2.7, 3.9])
floor_arr = np.floor(arr_float)   # [1, 2, 3]
ceil_arr = np.ceil(arr_float)     # [2, 3, 4]
round_arr = np.round(arr_float)   # [1, 3, 4]

print("Raíz cuadrada:", sqrt_arr)
print("Seno:", sin_arr)
print("Redondeado:", round_arr)
```
---
## 5. Broadcasting

El broadcasting permite que NumPy realice operaciones entre arrays de diferentes formas:

```python
# Broadcasting con arrays de diferentes dimensiones
arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6]])
arr_1d = np.array([10, 20, 30])

# El array 1D se "expande" para coincidir con el 2D
resultado = arr_2d + arr_1d
print("Broadcasting resultado:\n", resultado)
# [[11, 22, 33],
#  [14, 25, 36]]

# Broadcasting con escalares
matriz = np.ones((3, 4))
resultado_escalar = matriz * 5
print("Con escalar:\n", resultado_escalar)

# Ejemplo práctico: normalización
datos = np.random.random((100, 5))  # 100 muestras, 5 características
media = np.mean(datos, axis=0)      # Media por columna
desv_std = np.std(datos, axis=0)    # Desviación estándar por columna
datos_normalizados = (datos - media) / desv_std  # Broadcasting automático
```
---
## 6. Manipulación de forma (reshape)

```python
arr = np.arange(12)  # [0, 1, 2, ..., 11]

# Cambiar forma
arr_2d = arr.reshape(3, 4)    # 3 filas, 4 columnas
arr_3d = arr.reshape(2, 2, 3) # 2x2x3

# -1 para dimensión automática
arr_auto = arr.reshape(-1, 2)  # Número de filas automático, 2 columnas

# Aplanar arrays
arr_flat = arr_2d.flatten()    # Copia aplanada
arr_ravel = arr_2d.ravel()     # Vista aplanada (más eficiente)

# Transposición
arr_T = arr_2d.T               # Transpuesta
arr_transpose = np.transpose(arr_2d)  # Alternativa

print("Original 1D:", arr)
print("Reshaped 2D:\n", arr_2d)
print("Transpuesta:\n", arr_T)
```
---
## 7. Operaciones de agregación

```python
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# Agregaciones globales
print("Suma total:", np.sum(arr))           # 45
print("Media:", np.mean(arr))               # 5.0
print("Mediana:", np.median(arr))           # 5.0
print("Desviación estándar:", np.std(arr))  # 2.58
print("Varianza:", np.var(arr))             # 6.67
print("Mínimo:", np.min(arr))               # 1
print("Máximo:", np.max(arr))               # 9

# Agregaciones por eje
print("Suma por filas:", np.sum(arr, axis=1))     # [6, 15, 24]
print("Suma por columnas:", np.sum(arr, axis=0))  # [12, 15, 18]
print("Media por filas:", np.mean(arr, axis=1))   # [2, 5, 8]

# Posiciones de min/max
print("Índice del mínimo:", np.argmin(arr))        # 0
print("Índice del máximo:", np.argmax(arr))        # 8
```
---
## 8. Álgebra lineal con NumPy

```python
# Creación de matrices
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
v = np.array([1, 2])

# Multiplicación de matrices
producto_matriz = np.dot(A, B)        # Multiplicación matricial
producto_elemento = A * B             # Multiplicación elemento a elemento

# Operaciones con vectores
producto_escalar = np.dot(v, v)       # Producto escalar: v·v
norma = np.linalg.norm(v)             # Norma euclidiana

# Operaciones matriciales avanzadas
determinante = np.linalg.det(A)       # Determinante
inversa = np.linalg.inv(A)            # Matriz inversa
autovalores, autovectores = np.linalg.eig(A)  # Autovalores y autovectores

print("Producto matricial:\n", producto_matriz)
print("Determinante:", determinante)
print("Autovalores:", autovalores)

# Sistemas de ecuaciones lineales: Ax = b
b = np.array([5, 11])
x = np.linalg.solve(A, b)
print("Solución del sistema:", x)  # [1, 2]
```
---
## 9. Trabajo con datos faltantes y condiciones

```python
# Simulación de datos con NaN
datos = np.array([1.0, 2.0, np.nan, 4.0, 5.0])

# Detección de NaN
mask_nan = np.isnan(datos)
print("Posiciones NaN:", mask_nan)
print("Tiene NaN:", np.any(mask_nan))

# Funciones que ignoran NaN
media_sin_nan = np.nanmean(datos)     # Media ignorando NaN
suma_sin_nan = np.nansum(datos)       # Suma ignorando NaN

# Reemplazo de valores
datos_limpios = np.where(np.isnan(datos), 0, datos)  # Reemplazar NaN con 0

print("Media sin NaN:", media_sin_nan)
print("Datos limpios:", datos_limpios)

# Función where para condiciones complejas
arr = np.array([1, 2, 3, 4, 5, 6])
resultado = np.where(arr > 3, arr * 2, arr)  # Si >3: *2, sino: original
print("Condicional:", resultado)  # [1, 2, 3, 8, 10, 12]
```

---

## Ejercicios prácticos (25 min)

### Ejercicio 1: Operaciones básicas (5 min)

```python
import numpy as np

# Crea un array con los números del 1 al 10


# Calcula: cuadrado, raz cuadrada y logaritmo natural


# Filtra solo los números mayores que 5


# Calcula la media de los números pares


```

### Ejercicio 2: análisis de temperaturas (10 min)

```python
# Temperaturas de una semana (7 das) en 3 ciudades
# Filas = ciudades (Madrid, Barcelona, Valencia)
# Columnas = das
temperaturas = np.array([
    [22, 24, 23, 25, 26, 24, 23],  # Madrid
    [19, 21, 20, 22, 23, 21, 20],  # Barcelona
    [25, 27, 26, 28, 29, 27, 26]   # Valencia
])

# TODO:
# 1. Temperatura media por ciudad


# 2. Temperatura media por día


# 3. Día más caluroso en cada ciudad


# 4. Ciudad con mayor temperatura registrada


# 5. Días donde alguna ciudad supera los 27 grados


```

### Ejercicio 3: Procesamiento de imagen (10 min)

```python
# Simular una imagen en escala de grises 5x5 (valores 0-255)
imagen = np.random.randint(0, 256, size=(5, 5))

print("Imagen original:")
print(imagen)

# TODO:
# 1. Normalizar la imagen (valores entre 0 y 1)


# 2. Aplicar umbral: píxeles > 128 = 255, resto = 0 (binarización)


# 3. Calcular brillo promedio de la imagen


# 4. Aumentar brillo en un 20% (sin exceder 255)


# 5. Invertir la imagen (negativo): nuevo_valor = 255 - valor_actual


```
---
